**类加载机制**
Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称作**虚拟机的类加载机制**。
Java中，类型的加载、连接和初始化过程都是在**程序运行期间**完成的，这会增加一些性能开销，但是**Java可以动态扩展的语言特性**就是**依赖运行期动态加载和动态连接**这个特点实现的。

##### **类加载的时机**

一个类型从被加载到虚拟机内存开始，到卸载出内存位置，它的生命周期将会经历：
**<u>加载</u>** —> **<u>验证</u>** —> **<u>准备</u>** —> **解析** —> **<u>初始化</u>** —> **使用** —> **<u>卸载</u>**
上述过程中，加载、验证、准备、初始化、卸载这五个步骤的顺序是确定的，这些步骤是按照固定的顺序开始的，但是解析阶段不一定，可能会在初始化阶段之后再开始。
**类加载开始的时机**
Java虚拟机严格规定了有且只有六种情况必须立即对类进行加载：

* 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
  <u>使用new关键字实例化对象</u>
  <u>读取或者设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外)</u>
  <u>调用一个类型的静态方法时</u>
* 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行初始化，则需要先触发其初始化。
* 当初始化类时，发现父类还没有初始化，则需要先触发父类的初始化。
* 当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。
* 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic/REF_putStatic/REF_invokeStatic/REF_newInvokeSpecial四种类型的方法句柄时，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
* 当一个接口定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

##### **类加载的过程**

**加载**

在加载阶段，虚拟机需要完成一下三件事情：
1）通过一个类的全限定名来获取这个类的二进制字节流
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
加载阶段可以使用Java虚拟机里内置的引导类加载器完成，也可以由用户自定义的类加载器去完成。开发人员通过定义自己的类加载器去控制字节流的获取方式，实现根据自己的想法来赋予应用程序获取运行代码的动态性。
**数组类**本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但是数组中的元素最终可能还是要靠类加载器完成加载。**一个数组类C创建过程遵循以下规则：**
1 如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。
2 如果数组的组件类型不是引用类型，如int，Java虚拟机会将数组C标记为与引导类加载器关联。
3 数组类的可访问性和它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组累的可访问性将默认为public。

**验证**
这一阶段的**目的**：确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。
**验证阶段大致分为四个阶段验证：**
**<u>文件格式验证</u>**：只有通过这个阶段的验证之后，这段字字节流才被允许进入Java虚拟机内存的方法区中进行存储。后面三个验证阶段全部基于方法区的存储结构进行，不会再直接读取、操作字节流了。
**<u>元数据验证：</u>**对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。
**<u>字节码验证</u>:** 目的是通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的。上一阶段是对数据类型校验，这一阶段对类的方法体进行校验。
**<u>符号引用验证：</u>**这一阶段的校验行为发生在虚拟机将符号引用转为直接引用时。

**准备**
正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值。这些变量所使用的的内存都应当在方法区中进行分配。且初始值是指数据类型的零值。

**解析**
Java虚拟机将常量池中的符号引用转为直接引用。
**<u>符号引用:</u>** 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到虚拟机内存中。
**<u>直接引用：</u>** 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局直接相关，如果有了直接饮用，那引用的目标必定已经在虚拟机内存中了。
虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。

**初始化**
Java虚拟机真正开始执行类中编写的Javaz程序代码，将主导权交给应用程序。
初始化阶段就是执行类构造器<clinit>()方法的过程。
<clinit>()方法时由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
<clinit>()方法与类的构造函数不同，不需要显式调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()已经执行完毕。也就意味着父类的静态语句块要优于子类的变量赋值操作。接口和类不同，执行接口的<clinit>()不需要先执行父接口的<clinit>()。因为只有当父接口定义的变量被使用时，父接口才会被初始化。

##### **类加载器**

类加载阶段中“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作是在Java虚拟机外部实现的，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码称为**类加载器**。
**类与类加载器**
**类的唯一性：**对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。也就是说，在比较两个类是否相等时，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

**双亲委派模型**
从<u>Java虚拟机的角度</u>来看，只存在两种不同的类加载器：一种是**启动类加载器**，由**C++语言**实现，是虚拟机自身的一部分；另外一种是其他所有的类加载器，这些类加载器由**Java语言**实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。
从<u>开发人员角度</u>来看，Java有**三层类加载器**和**双亲委派**的类加载架构。
**三层类加载器：**
**<u>启动类加载器：</u>**由C++语言实现，是虚拟机的一部分，这个类加载器负责加载存放在``<JAVA_HOME>\lib``目录，或者被``-Xbootclasspath``参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。它不能直接被Java程序直接引用，用户在编写自定义类加载器的时候，如果需要把家在请求委派给这个加载器去处理，就直接使用null代替。
**<u>扩展类加载器：</u>**这个类加载器是Java实现的，负责加载``<JAVA_HOME>\lib\ext``目录中的类库。是Java系统类库的扩展机制。JDK的开发团队允许用户将具有通用性的类库放置在ext目录里易扩展Java SE的功能。开发者可以直接在程序中使用扩展类加载器加载Class文件。
**<u>应用程序类加载器：</u>**负责加载用户类路径（ClassPath）上所有的类库。开发者可以直接在代码中使用这个类加载器。
**双亲委派模型：** 除了启动类加载器外，其余的类加载器都应有自己的父类加载器。如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求**委派给父类加载器**去完成，每个层次的类加载器都是如此，因此所有的加载器请求最终都应该传送到顶层的启动类加载器中，只有**当父加载器反馈自己无法完成这个加载请求**时，子加载器才会尝试自己取完成加载。

**破坏双亲委派模型**
**JDNI服务：** JDNI是Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口（SPI）的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。Java使用线程上下文类加载器打破双亲委派模型，JNDI服务使用线程上下文类加载器去加载锁需要的SPI服务代码。



